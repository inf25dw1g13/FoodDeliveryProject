# Capítulo 5: Base de Dados 

## Introdução

Este capítulo descreve a implementação técnica da camada de base de dados do projeto Food Delivery, focando em três aspetos fundamentais:

1. **Propriedades ACID**: Garantia de transações confiáveis
2. **Sistema de Audit**: Rastreamento de alterações na base de dados
3. **Replicação e Alta Disponibilidade**: Arquitetura Master-Replica com MaxScale

## Propriedades ACID

### Conceito

ACID é um acrónimo que representa quatro propriedades fundamentais que garantem a confiabilidade das transações em bases de dados:

- **Atomicidade**: Uma transação é uma unidade indivisível - ou todas as operações são executadas com sucesso, ou nenhuma é executada
- **Consistência**: A base de dados permanece num estado válido antes e depois da transação
- **Isolamento**: Transações concorrentes não interferem entre si
- **Durabilidade**: Alterações commitadas persistem mesmo após falhas do sistema

### Implementação 

O projeto implementa tabmém, testes em Python [`test_acid.py`](/extra/test_acid.py) que validam cada uma das propriedades ACID com **4 cenários de teste por propriedade**, totalizando **16 testes**.

#### Testes de Atomicidade

**Teste 1: Transação Completa**
- Cria um restaurante e um prato associado numa única transação
- Verifica que ambos são criados após commit

**Teste 2: Rollback Parcial**
- Inicia uma transação com múltiplas operações
- Força um erro a meio
- Verifica que nenhuma alteração foi persistida

**Teste 3: Transação com Múltiplas Tabelas**
- Cria múltiplas entidades relacionadas numa única transação (cliente, restaurante, pedido)
- Verifica que todas as entidades são criadas e commitadas em conjunto

**Teste 4: Transação sem Commit**
- Cria registos numa transação mas não faz commit
- Verifica que nenhum registo persiste após rollback (atomicidade)

#### Testes de Consistência

**Teste 1: Constraints de Chave Estrangeira**
- Tenta criar um prato com restaurante_id inválido
- Verifica que a foreign key constraint é respeitada e a operação é rejeitada
- Garante integridade referencial

**Teste 2: Constraints de Valores Únicos (UNIQUE)**
- Tenta inserir duas categorias de pratos com o mesmo nome
- Verifica que apenas a primeira é aceite (constraint UNIQUE em `categorias_pratos.nome`)

**Teste 3: Consistência após Update**
- Atualiza um valor existente (ex: nome de restaurante)
- Verifica que a atualização é persistida corretamente e mantém consistência

**Teste 4: Relações 1:n**
- Cria múltiplos registos relacionados (ex: um restaurante com vários pratos)
- Verifica que a relação 1:n mantém consistência (todos os pratos pertencem ao restaurante correto)

#### Testes de Isolamento

**Teste 1: Dirty Read Prevention**
- Transação 1 cria um registo mas não commita
- Transação 2 não consegue ver o registo não commitado

**Teste 2: Read Committed**
- Transação 1 commita uma alteração
- Transação 2 vê a alteração após o commit

**Teste 3: Non-repeatable Read**
- Transação 2 lê um valor (nome de restaurante)
- Transação 1 altera o valor e commita
- Transação 2 lê novamente e pode ver a mudança (depende do nível de isolamento configurado)
- Testa o comportamento do isolamento em relação a leituras repetidas

**Teste 4: Phantom Reads**
- Testa se novos registos inseridos por outra transação são visíveis
- Valida o nível de isolamento configurado

#### Testes de Durabilidade

**Teste 1: Commit Persistente**
- Commita uma transação
- Reinicia a conexão
- Verifica que os dados persistem

**Teste 2: Crash Recovery**
- Simula uma falha durante uma transação
- Verifica que apenas dados commitados são recuperados

**Teste 3: Binary Log Durability**
- Verifica que operações são registadas no binlog
- Garante que podem ser replicadas

**Teste 4: Transaction Log**
- Valida que o InnoDB escreve no transaction log
- Garante durabilidade mesmo com falhas de energia


### Execução dos Testes

**Pré-requisitos:**

 - **Python 3** instalado no sistema
-  **Biblioteca mysql-connector-python** instalada:
   ```bash
   pip3 install mysql-connector-python
   ```
-  **Container Docker do MariaDB Master** a correr


**Executar testes ACID:**

```bash
# Navegar para o diretório do projeto
cd extra

# Executar os testes
python3 test_acid.py
```


**Exemplo de código do teste de Atomicidade 1:**

```python
def test_atomicity_1():
    """Teste 1: Transação completa deve ser commitada"""
    conn = get_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        # Iniciar transação
        conn.start_transaction()
        
        # Criar codpostal se não existir
        cursor.execute("""
            INSERT IGNORE INTO codpostal (codpostal, localidade, cidade)
            VALUES ('1000-001', 'Lisboa', 'Lisboa')
        """)
        
        # Obter ou criar categoria
        cursor.execute("SELECT id FROM categorias_pratos WHERE nome = 'Teste' LIMIT 1")
        cat_result = cursor.fetchone()
        if cat_result:
            categoria_id = cat_result[0]
        else:
            cursor.execute("INSERT INTO categorias_pratos (nome) VALUES ('Teste')")
            categoria_id = cursor.lastrowid
        
        # Criar restaurante (incluindo todos os campos obrigatórios do schema)
        cursor.execute("""
            INSERT INTO restaurantes (nome, morada, codpostal, email, telefone, especialidade_id)
            VALUES ('Teste Atomic 1', 'Rua Teste', '1000-001', 'teste.atomic1@test.pt', '999999999', %s)
        """, (categoria_id,))
        restaurante_id = cursor.lastrowid
        
        # Criar prato associado
        cursor.execute("""
            INSERT INTO pratos (restaurante_id, categoria_id, nome, preco)
            VALUES (%s, %s, 'Prato Teste', 10.50)
        """, (restaurante_id, categoria_id))
        
        # Commit - ambas as operações são persistidas juntas
        conn.commit()
        
        # Verificar se ambos foram criados
        cursor.execute("SELECT COUNT(*) FROM restaurantes WHERE id = %s", (restaurante_id,))
        restaurante_exists = cursor.fetchone()[0] > 0
        
        cursor.execute("SELECT COUNT(*) FROM pratos WHERE restaurante_id = %s", (restaurante_id,))
        prato_exists = cursor.fetchone()[0] > 0
        
        result = restaurante_exists and prato_exists
        
        # Limpeza
        cursor.execute("DELETE FROM pratos WHERE restaurante_id = %s", (restaurante_id,))
        cursor.execute("DELETE FROM restaurantes WHERE id = %s", (restaurante_id,))
        conn.commit()
        
        return result
    except Error as e:
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()
```

## Sistema de Audit

### Conceito

O sistema de audit permite rastrear todas as alterações realizadas na base de dados, registando:
- **Quem** alterou (utilizador)
- **O que** foi alterado (tabela, registo, operação)
- **Quando** foi alterado (timestamp)
- **Valores anteriores e novos** (dados completos em JSON)

#### Tabela de Audit

```sql
CREATE TABLE IF NOT EXISTS audit_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    tabela_nome VARCHAR(50) NOT NULL,
    operacao ENUM('INSERT','UPDATE','DELETE') NOT NULL,
    registro_id INT,
    dados_anteriores JSON,
    dados_novos JSON,
    utilizador VARCHAR(50),
    data_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_tabela (tabela_nome),
    INDEX idx_data (data_hora)
);
```

#### Triggers de Audit

Para cada tabela crítica do sistema, foram criados três triggers:

1. **AFTER INSERT**: Regista novos registos
2. **AFTER UPDATE**: Regista alterações (valores antigos e novos)
3. **AFTER DELETE**: Regista eliminações

**Exemplo - Triggers para a tabela `restaurantes`:**

```sql
-- Trigger para INSERT
CREATE TRIGGER audit_restaurantes_insert
AFTER INSERT ON restaurantes
FOR EACH ROW
BEGIN
    INSERT INTO audit_log(tabela_nome, operacao, registro_id, dados_novos)
    VALUES ('restaurantes','INSERT', NEW.id,
        JSON_OBJECT('nome', NEW.nome, 'morada', NEW.morada, 'codpostal', NEW.codpostal, 
                    'email', NEW.email, 'telefone', NEW.telefone, 'especialidade_id', NEW.especialidade_id, 
                    'hora_abertura', NEW.hora_abertura, 'hora_fecho', NEW.hora_fecho, 
                    'estado', NEW.estado, 'descricao', NEW.descricao, 'taxa_entrega', NEW.taxa_entrega)
    );
END;

-- Trigger para UPDATE
CREATE TRIGGER audit_restaurantes_update
AFTER UPDATE ON restaurantes
FOR EACH ROW
BEGIN
    INSERT INTO audit_log(tabela_nome, operacao, registro_id, dados_anteriores, dados_novos)
    VALUES ('restaurantes','UPDATE', OLD.id,
        JSON_OBJECT('nome', OLD.nome, 'morada', OLD.morada, 'codpostal', OLD.codpostal, 
                    'email', OLD.email, 'telefone', OLD.telefone, 'especialidade_id', OLD.especialidade_id, 
                    'hora_abertura', OLD.hora_abertura, 'hora_fecho', OLD.hora_fecho, 
                    'estado', OLD.estado, 'descricao', OLD.descricao, 'taxa_entrega', OLD.taxa_entrega),
        JSON_OBJECT('nome', NEW.nome, 'morada', NEW.morada, 'codpostal', NEW.codpostal, 
                    'email', NEW.email, 'telefone', NEW.telefone, 'especialidade_id', NEW.especialidade_id, 
                    'hora_abertura', NEW.hora_abertura, 'hora_fecho', NEW.hora_fecho, 
                    'estado', NEW.estado, 'descricao', NEW.descricao, 'taxa_entrega', NEW.taxa_entrega)
    );
END;

-- Trigger para DELETE
CREATE TRIGGER audit_restaurantes_delete
AFTER DELETE ON restaurantes
FOR EACH ROW
BEGIN
    INSERT INTO audit_log(tabela_nome, operacao, registro_id, dados_anteriores)
    VALUES ('restaurantes','DELETE', OLD.id,
        JSON_OBJECT('nome', OLD.nome, 'morada', OLD.morada, 'codpostal', OLD.codpostal, 
                    'email', OLD.email, 'telefone', OLD.telefone, 'especialidade_id', OLD.especialidade_id, 
                    'hora_abertura', OLD.hora_abertura, 'hora_fecho', OLD.hora_fecho, 
                    'estado', OLD.estado, 'descricao', OLD.descricao, 'taxa_entrega', OLD.taxa_entrega)
    );
END;
```

#### Tabelas Auditadas

O sistema de audit cobre todas as tabelas :
- `codpostal`
- `categorias_pratos`
- `ingredientes`
- `restaurantes`
- `pratos`
- `pratos_ingredientes`
- `clientes`
- `entregadores`
- `pedidos`
- `pedidos_pratos`
- `entregas`

#### Consulta do Audit Log

Uma view foi criada para facilitar a consulta:

```sql
CREATE OR REPLACE VIEW view_audit_log AS
SELECT 
    id,
    tabela_nome,
    operacao,
    registro_id,
    JSON_PRETTY(dados_anteriores) AS dados_anteriores_formatados,
    JSON_PRETTY(dados_novos) AS dados_novos_formatados,
    utilizador,
    data_hora
FROM audit_log
ORDER BY data_hora DESC;
```

**Exemplo de consulta:**

```sql
-- Ver todas as alterações recentes
SELECT * FROM view_audit_log LIMIT 10;

-- Ver alterações numa tabela específica
SELECT * FROM view_audit_log WHERE tabela_nome = 'restaurantes';

-- Ver alterações num registo específico
SELECT * FROM view_audit_log 
WHERE tabela_nome = 'pedidos' AND registro_id = 100;
```

### Como Funciona o Sistema de Audit

O sistema de audit funciona através de **triggers de base de dados** que são executados automaticamente após cada operação (INSERT, UPDATE, DELETE) nas tabelas auditadas. O processo funciona da seguinte forma:

1. **Operação na tabela**: Uma aplicação executa um INSERT, UPDATE ou DELETE numa tabela auditada
2. **Trigger disparado**: O trigger correspondente é executado automaticamente pelo MariaDB
3. **Registo no audit_log**: O trigger insere um novo registo na tabela `audit_log` com:
   - Informação sobre a operação (tabela, operação, ID do registo)
   - Dados completos em formato JSON (valores antigos para UPDATE/DELETE, valores novos para INSERT/UPDATE)
   - Timestamp automático da operação
4. **Armazenamento persistente**: O registo fica permanentemente na tabela `audit_log` para consulta futura


### Exemplos da Utilização do Audit

**1. Ver todas as alterações recentes:**

```sql
-- Consultar as últimas 10 alterações
SELECT * FROM view_audit_log LIMIT 10;
```

**2. Ver alterações numa tabela específica:**

```sql
-- Ver todas as alterações na tabela restaurantes
SELECT * FROM view_audit_log 
WHERE tabela_nome = 'restaurantes' 
ORDER BY data_hora DESC;
```

**3. Ver alterações num registo específico:**

```sql
-- Ver histórico completo de alterações num pedido específico
SELECT * FROM view_audit_log 
WHERE tabela_nome = 'pedidos' AND registro_id = 100
ORDER BY data_hora DESC;
```

**4. Ver quem alterou um restaurante (exemplo prático):**

```sql
-- Fazer uma alteração (exemplo)
UPDATE restaurantes SET nome = 'Restaurante Auditado' WHERE id = 1;

-- Verificar se foi registado no audit log
SELECT 
    operacao,
    data_hora,
    JSON_EXTRACT(dados_anteriores, '$.nome') AS nome_anterior,
    JSON_EXTRACT(dados_novos, '$.nome') AS nome_novo
FROM audit_log 
WHERE tabela_nome = 'restaurantes' AND registro_id = 1
ORDER BY data_hora DESC 
LIMIT 5;
```

**5. Consulta via Docker (comando prático):**

```bash
# Ver as últimas entradas do log de auditoria
docker exec -it food_delivery_master mysql -uroot -proot_password food_delivery \
  -e "SELECT * FROM view_audit_log LIMIT 10;"

# Fazer uma alteração e verificar
docker exec -it food_delivery_master mysql -uroot -proot_password food_delivery \
  -e "UPDATE restaurantes SET nome='Restaurante Auditado' WHERE id=1;"

docker exec -it food_delivery_master mysql -uroot -proot_password food_delivery \
  -e "SELECT * FROM view_audit_log WHERE tabela_nome='restaurantes' ORDER BY data_hora DESC LIMIT 1;"
```

## Replicação e Alta Disponibilidade

### Arquitetura

O projeto implementa uma arquitetura de replicação Master-Replica com **1 servidor Master** e **2 servidores Replica**, utilizando **MaxScale** como proxy de base de dados.


### Replicação MariaDB

#### Configuração do Master

**Ficheiro `my.cnf` do Master:**

```ini
[mysqld]
server-id=1
gtid_strict_mode=1
gtid_domain_id=1
log-bin=mysql-bin 
binlog-format=ROW
sync-binlog=1
binlog-do-db=food_delivery
```

**Características:**
- **GTID (Global Transaction ID)**: Permite replicação baseada em transações, facilitando failover
- **Binary Logging**: Regista todas as alterações para replicação
- **ROW format**: Replica alterações linha a linha (mais seguro)

#### Configuração das Réplicas

**Ficheiro `my.cnf` das Réplicas:**

```ini
[mysqld]
server-id=2  # ou 3 para replica2
read-only=1
relay-log=relay-bin
log-slave-updates=1
```

**Script de Setup (`01_setup_replication.sh`):**

```bash
#!/bin/bash
# Script para configurar replicação na réplica
# Aguarda o master estar pronto e depois configura a replicação

# Para replicação se estiver a rodar
STOP SLAVE;

# Reseta replicação 
RESET SLAVE ALL;

# Reseta binlogs da réplica para começar do zero
RESET MASTER;

# Configura replicação usando GTID
CHANGE MASTER TO
    MASTER_HOST='mariadb-master',
    MASTER_USER='repl',
    MASTER_PASSWORD='repl_password',
    MASTER_USE_GTID=slave_pos;

# Inicia replicação
START SLAVE;
```

#### Como Funciona a Replicação (Explicação Técnica Detalhada)

A replicação MariaDB funciona através de um processo assíncrono baseado em logs binários (binary logs). O processo completo funciona da seguinte forma:

**1. Escrita no Master:**
- Quando uma operação de escrita (INSERT, UPDATE, DELETE) é executada no Master, o MariaDB regista a operação no **binary log** (binlog) em formato binário compacto
- O binary log contém todos os eventos que modificam dados, incluindo:
  - Statements (SQL statements) - no formato STATEMENT
  - Row changes (alterações linha a linha) - no formato ROW (usado neste projeto)
  - Metadata (informações sobre a operação)

**2. GTID (Global Transaction ID):**
- Cada transação commitada recebe um GTID único (ex: `1-1-197`)
- O GTID permite rastrear transações de forma única em toda a topologia
- Facilita o failover e o auto-rejoin, pois as réplicas sabem exatamente qual foi a última transação aplicada

**3. Conexão das Réplicas:**
- Cada réplica mantém uma **thread I/O** que se conecta ao Master
- A thread I/O pede eventos do binary log ao Master, especificando o GTID a partir do qual quer receber eventos
- O Master envia os eventos binários através da conexão de rede

**4. Relay Log:**
- A réplica recebe os eventos e escreve-os no **relay log** (log de retransmissão)
- O relay log é local à réplica e serve como buffer temporário

**5. Aplicação nas Réplicas:**
- Uma **thread SQL** na réplica lê eventos do relay log
- A thread SQL aplica os eventos sequencialmente na base de dados local
- Os eventos são aplicados na mesma ordem em que foram commitados no Master

**6. Sincronização:**
- A réplica mantém o registo do último GTID aplicado
- O lag (atraso) é medido pela diferença entre o GTID do Master e o GTID da réplica
- Em condições normais, o lag é mínimo (milissegundos)

**Verificar status da replicação:**

```sql
-- No Master - Ver posição atual do binary log
SHOW MASTER STATUS;
-- Output:
-- File: mysql-bin.000002
-- Position: 342
-- Binlog_Do_DB: food_delivery
-- Binlog_Ignore_DB:
-- Executed_Gtid_Set: 1-1-197

-- Nas Réplicas - Ver status detalhado da replicação
SHOW SLAVE STATUS\G

-- Verificar campos importantes:
-- Slave_IO_Running: Yes (thread I/O está a correr)
-- Slave_SQL_Running: Yes (thread SQL está a correr)
-- Seconds_Behind_Master: 0 (réplica está sincronizada, sem lag)
-- Executed_Gtid_Set: 1-1-197 (último GTID aplicado)
-- Master_Host: mariadb-master
-- Master_Port: 3306
```

**Comandos práticos:**

```bash
# Ver status do Master
docker exec -it food_delivery_master mysql -uroot -proot_password \
  -e "SHOW MASTER STATUS;"

# Ver status de uma réplica
docker exec -it food_delivery_replica1 mysql -uroot -proot_password \
  -e "SHOW SLAVE STATUS\G" | grep -E "Slave_IO_Running|Slave_SQL_Running|Seconds_Behind_Master|Executed_Gtid_Set"
```

### MaxScale - Proxy de Base de Dados

#### Conceito

MaxScale é um proxy de base de dados que:
- **Roteia queries**: Envia escritas para o Master e leituras para as Réplicas
- **Monitora servidores**: Verifica saúde dos servidores a cada 2 segundos
- **Auto-failover**: Promove uma réplica a Master se o Master cair
- **Auto-rejoin**: Reconecta servidores que voltam online

#### Configuração

**Ficheiro `maxscale.cnf.ini`:**

```ini
[maxscale]
threads=auto
admin_host=0.0.0.0
admin_port=8989
admin_secure_gui=false

# Definir servidores
[master-server]
type=server
address=mariadb-master
port=3306
protocol=MariaDBBackend

[replica1-server]
type=server
address=mariadb-replica1
port=3306
protocol=MariaDBBackend

[replica2-server]
type=server
address=mariadb-replica2
port=3306
protocol=MariaDBBackend

# Monitor (vigia os servidores)
[MariaDB-Monitor]
type=monitor
module=mariadbmon
servers=master-server,replica1-server,replica2-server
user=root
password=root_password
monitor_interval=2000ms
auto_failover=true      #  Promove réplica a Master se Master cair
auto_rejoin=true        #  Reconecta servidores que voltam online
enforce_read_only_slaves=true

# Service (distribui queries)
[Read-Write-Service]
type=service
router=readwritesplit   #  Router que separa leituras e escritas
servers=master-server,replica1-server,replica2-server
user=root
password=root_password
enable_root_user=true
use_sql_variables_in=all
slave_selection_criteria=LEAST_CURRENT_OPERATIONS

# Listener (porta de entrada)
[Read-Write-Listener]
type=listener
service=Read-Write-Service
protocol=MariaDBClient
port=4006
address=0.0.0.0
```

#### Read/Write Split

O router `readwritesplit` funciona da seguinte forma:

- **Escritas** (`INSERT`, `UPDATE`, `DELETE`, `CREATE`, `ALTER`, etc.): Sempre enviadas para o **Master**
- **Leituras** (`SELECT`): Distribuídas entre as **Réplicas** (balanceamento de carga)
- **Transações**: Escritas dentro de transações também vão para o Master

**Exemplo:**

```sql
-- Via MaxScale (porta 4006)
-- Esta escrita vai para o Master
INSERT INTO pedidos (cliente_id, restaurante_id, metodo_pagamento) 
VALUES (1, 1, 'cartao');

-- Estas leituras vão para as Réplicas (alternando)
SELECT * FROM pedidos;
SELECT * FROM pedidos;  -- Pode ir para outra réplica
SELECT * FROM pedidos;  -- Pode ir para outra réplica
```

#### Auto-Failover

Quando o Master cai:

1. **MaxScale detecta**: O monitor verifica o Master a cada 2 segundos
2. **Promoção automática**: MaxScale promove uma réplica a Master
3. **Reconfiguração**: As outras réplicas são reconfiguradas para replicar do novo Master
4. **Aplicação continua**: A aplicação continua a funcionar 

**Verificar roles dos servidores:**

```bash
docker exec -it food_delivery_maxscale maxctrl list servers
```

#### Auto-Rejoin

Quando o Master original volta online:

1. **MaxScale detecta**: O monitor verifica que o servidor voltou
2. **Reconfiguração**: O servidor é reconfigurado como réplica do novo Master
3. **Sincronização**: O servidor sincroniza com o Master atual
4. **Reintegração**: O servidor volta a estar disponível para leituras

O auto-rejoin do MaxScale:
- O Master cai e uma réplica é promovida
- O Master original volta online e é reconhecido como réplica

**Verificar se auto-rejoin funcionou:**

```bash
# Ver status dos servidores
docker exec -it food_delivery_maxscale maxctrl list servers

# Ver logs do MaxScale
docker logs food_delivery_maxscale | grep -i rejoin
```

## Monitorização

### MaxScale Dashboard

Aceder ao dashboard do MaxScale:
- **URL**: http://localhost:8989
- **Credenciais**: admin / mariadb

O dashboard permite:
- Ver status de todos os servidores
- Monitorizar queries em tempo real
- Ver estatísticas de conexões
- Verificar saúde dos servidores

### Comandos Úteis

```bash
# Ver status dos servidores
docker exec -it food_delivery_maxscale maxctrl list servers

# Ver estatísticas
docker exec -it food_delivery_maxscale maxctrl show servers

# Ver conexões ativas
docker exec -it food_delivery_maxscale maxctrl list sessions

# Verificar replicação no Master
docker exec -it food_delivery_master mysql -uroot -proot_password -e "SHOW MASTER STATUS;"

# Verificar replicação nas Réplicas
docker exec -it food_delivery_replica1 mysql -uroot -proot_password -e "SHOW SLAVE STATUS\G"
```

## Descrição Técnica do Projeto

### Arquitetura da Base de Dados

O projeto implementa uma arquitetura de base de dados robusta e escalável, baseada em:

**1. Motor de Base de Dados:**
- **MariaDB 11.2**: Sistema de gestão de base de dados relacional, compatível com MySQL
- **InnoDB Storage Engine**: Motor de armazenamento transacional que garante ACID
- **GTID (Global Transaction ID)**: Sistema de identificação única de transações para replicação confiável

**2. Arquitetura de Replicação:**
- **Topologia Master-Replica**: 1 servidor Master (escritas) + 2 servidores Replica (leituras)
- **Replicação Baseada em GTID**: Permite failover e rejoin automáticos
- **Binary Logging ROW format**: Replicação linha a linha para maior confiabilidade

**3. Proxy de Base de Dados:**
- **MaxScale 23.08**: Proxy que implementa read/write splitting
- **Router ReadWriteSplit**: Separa automaticamente escritas (Master) e leituras (Réplicas)
- **Monitor MariaDB-Monitor**: Verifica saúde dos servidores a cada 2 segundos

**4. Sistema de Audit:**
- **Triggers Automáticos**: 33 triggers (3 por tabela: INSERT, UPDATE, DELETE)
- **Armazenamento JSON**: Dados armazenados em formato JSON para flexibilidade
- **View de Consulta**: View `view_audit_log` para consultas facilitadas

**5. Garantias ACID:**
- **Testes Automatizados**: 16 testes Python que validam todas as propriedades ACID
- **4 testes por propriedade**: Cobertura completa de atomicidade, consistência, isolamento e durabilidade

### Tecnologias

**Base de Dados:**
- MariaDB 11.2 (compatível MySQL)
- MaxScale 23.08
- Docker & Docker Compose

**Linguagens e Ferramentas:**
- SQL (DDL, DML, Triggers, Views)
- Python 3 (testes ACID)
- Bash (scripts de backup, restore, failover)
- Docker (containerização)

**Conceitos Implementados:**
- Replicação Master-Replica
- Read/Write Splitting
- Auto-Failover e Auto-Rejoin
- Database Triggers
- Binary Logging
- GTID-based Replication
- Transaction Logging
- ACID Properties


## Conclusão  

Esta arquitetura é adequada para ambientes de produção, garantindo que o sistema continue a funcionar mesmo em caso de falhas e permitindo escalar horizontalmente conforme a carga aumenta. Os desafios encontrados durante o desenvolvimento foram superados através de pesquisa, diferentes testes e debugging, e da sua respetiva documentação.  

---  
[< Previous](c4.md) | [^ Main](../../../) | 
:--- | :---: | 















